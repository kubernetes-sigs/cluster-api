/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1beta2

// ClusterSpecApplyConfiguration represents a declarative configuration of the ClusterSpec type for use
// with apply.
//
// ClusterSpec defines the desired state of Cluster.
type ClusterSpecApplyConfiguration struct {
	// paused can be used to prevent controllers from processing the Cluster and all its associated objects.
	Paused *bool `json:"paused,omitempty"`
	// clusterNetwork represents the cluster network configuration.
	ClusterNetwork *ClusterNetworkApplyConfiguration `json:"clusterNetwork,omitempty"`
	// controlPlaneEndpoint represents the endpoint used to communicate with the control plane.
	ControlPlaneEndpoint *APIEndpointApplyConfiguration `json:"controlPlaneEndpoint,omitempty"`
	// controlPlaneRef is an optional reference to a provider-specific resource that holds
	// the details for provisioning the Control Plane for a Cluster.
	ControlPlaneRef *ContractVersionedObjectReferenceApplyConfiguration `json:"controlPlaneRef,omitempty"`
	// infrastructureRef is a reference to a provider-specific resource that holds the details
	// for provisioning infrastructure for a cluster in said provider.
	InfrastructureRef *ContractVersionedObjectReferenceApplyConfiguration `json:"infrastructureRef,omitempty"`
	// topology encapsulates the topology for the cluster.
	// NOTE: It is required to enable the ClusterTopology
	// feature gate flag to activate managed topologies support;
	// this feature is highly experimental, and parts of it might still be not implemented.
	Topology *TopologyApplyConfiguration `json:"topology,omitempty"`
	// availabilityGates specifies additional conditions to include when evaluating Cluster Available condition.
	//
	// If this field is not defined and the Cluster implements a managed topology, availabilityGates
	// from the corresponding ClusterClass will be used, if any.
	AvailabilityGates []ClusterAvailabilityGateApplyConfiguration `json:"availabilityGates,omitempty"`
}

// ClusterSpecApplyConfiguration constructs a declarative configuration of the ClusterSpec type for use with
// apply.
func ClusterSpec() *ClusterSpecApplyConfiguration {
	return &ClusterSpecApplyConfiguration{}
}

// WithPaused sets the Paused field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Paused field is set to the value of the last call.
func (b *ClusterSpecApplyConfiguration) WithPaused(value bool) *ClusterSpecApplyConfiguration {
	b.Paused = &value
	return b
}

// WithClusterNetwork sets the ClusterNetwork field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClusterNetwork field is set to the value of the last call.
func (b *ClusterSpecApplyConfiguration) WithClusterNetwork(value *ClusterNetworkApplyConfiguration) *ClusterSpecApplyConfiguration {
	b.ClusterNetwork = value
	return b
}

// WithControlPlaneEndpoint sets the ControlPlaneEndpoint field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ControlPlaneEndpoint field is set to the value of the last call.
func (b *ClusterSpecApplyConfiguration) WithControlPlaneEndpoint(value *APIEndpointApplyConfiguration) *ClusterSpecApplyConfiguration {
	b.ControlPlaneEndpoint = value
	return b
}

// WithControlPlaneRef sets the ControlPlaneRef field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ControlPlaneRef field is set to the value of the last call.
func (b *ClusterSpecApplyConfiguration) WithControlPlaneRef(value *ContractVersionedObjectReferenceApplyConfiguration) *ClusterSpecApplyConfiguration {
	b.ControlPlaneRef = value
	return b
}

// WithInfrastructureRef sets the InfrastructureRef field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the InfrastructureRef field is set to the value of the last call.
func (b *ClusterSpecApplyConfiguration) WithInfrastructureRef(value *ContractVersionedObjectReferenceApplyConfiguration) *ClusterSpecApplyConfiguration {
	b.InfrastructureRef = value
	return b
}

// WithTopology sets the Topology field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Topology field is set to the value of the last call.
func (b *ClusterSpecApplyConfiguration) WithTopology(value *TopologyApplyConfiguration) *ClusterSpecApplyConfiguration {
	b.Topology = value
	return b
}

// WithAvailabilityGates adds the given value to the AvailabilityGates field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the AvailabilityGates field.
func (b *ClusterSpecApplyConfiguration) WithAvailabilityGates(values ...*ClusterAvailabilityGateApplyConfiguration) *ClusterSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithAvailabilityGates")
		}
		b.AvailabilityGates = append(b.AvailabilityGates, *values[i])
	}
	return b
}
