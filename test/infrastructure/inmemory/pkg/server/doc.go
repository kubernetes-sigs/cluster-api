/*
Copyright 2023 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/*
Package server implements a server that can be used to fake the APIServer and etcd running
in the workload clusters; the implementation is designed specifically to make Cluster API
and the Kubeadm Control Plane provider happy during a stress test (it is not complete or
production ready, and it will never be).

There are many factors shaping the implementation.

  - The server has to be able to serve requests for many workload clusters.
  - The server has to serve all kind of requests CAPI core controllers and the kubeadm
    control plane controller are sending to workload clusters
  - Among those request there are also two port-forward requests, one targeting the
    kube-apiserver pods, the other the etcd pods generated by kubeadm. The server has to
    be able to act as a target for those requests too (it will port forward to itself).
  - The server needs to comply to the CAPI contract, e.g. the control plane endpoint is in the
    form of host:port, the port is allocated first but the server starts answering later when
    the first CP instance comes up etc.

The implementation is inspired from https://fideloper.com/golang-proxy-multiple-listeners
(kudos to the author!), and it consists of a server that has support for multiplexing requests for
many workload clusters, each one with its own host:port listener, to a single handler/backend
implementation.
*/
package server
