/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"bytes"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"

	"github.com/pkg/errors"
	"k8s.io/klog/v2"
	"sigs.k8s.io/yaml"
)

const generatedFileHeader = "# Code generated by cluster-api's prowjob-gen. DO NOT EDIT.\n"

// newGenerator initializes a generator which includes parsing the configured templates.
func newGenerator(configFile string, templatesDir, outputDir string) (*generator, error) {
	// Read and Unmarshal the configuration file.
	rawConfig, err := os.ReadFile(filepath.Clean(configFile))
	if err != nil {
		return nil, errors.Wrapf(err, "reading config file %s", configFile)
	}
	prowIgnoredConfig := ProwIgnoredConfig{}
	if err := yaml.UnmarshalStrict(rawConfig, &prowIgnoredConfig); err != nil {
		return nil, errors.Wrapf(err, "parsing config file %s", configFile)
	}

	g := &generator{
		config:        prowIgnoredConfig.ProwIgnored,
		outputDir:     outputDir,
		nameTemplates: map[string]*template.Template{},
	}

	g.templates, err = template.New("").
		Funcs(g.templateFunctions()).
		ParseGlob(templatesDir + "/*.yaml.tpl")
	if err != nil {
		return nil, err
	}

	for _, tpl := range g.config.Templates {
		nameTemplate, err := template.New("").Funcs(g.templateFunctions()).Parse(tpl.Template)
		if err != nil {
			return nil, errors.Wrapf(err, "parsing name template %q", tpl.Template)
		}
		g.nameTemplates[tpl.Name] = nameTemplate
	}

	return g, nil
}

type generator struct {
	templates     *template.Template
	nameTemplates map[string]*template.Template
	config        Config
	outputDir     string
}

// generate executes every template for every branch and writes the result to a
// file in outputDir.
func (g *generator) generate() error {
	for _, tpl := range g.config.Templates {
		for branch := range g.config.Branches {
			klog.Infof("Executing and writing template %q for branch %q", tpl.Name, branch)
			out, err := g.executeTemplate(branch, tpl.Name)
			if err != nil {
				return errors.Wrapf(err, "Generating prowjobs for template %s", tpl.Name)
			}

			if out.Len() == len(generatedFileHeader) {
				klog.Infof("Skipping template %s for branch %s because the resulting file would have been empty", tpl.Name, branch)
				continue
			}

			fileName, err := g.executeNameTemplate(branch, tpl.Name)
			if err != nil {
				return errors.Wrapf(err, "Generating name for template %s and branch %s", tpl.Name, branch)
			}
			filePath := filepath.Clean(path.Join(g.outputDir, fileName))
			if err := os.WriteFile(filePath, out.Bytes(), 0644); err != nil { //nolint:gosec
				return errors.Wrapf(err, "Writing prowjob to %q", filePath)
			}
		}
	}
	return nil
}

// cleanup deletes files which have the generatedFileHeader.
func (g *generator) cleanup() error {
	entries, err := os.ReadDir(g.outputDir)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		path := filepath.Clean(path.Join(g.outputDir, entry.Name()))
		data, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		if strings.HasPrefix(string(data), generatedFileHeader) {
			klog.Infof("Deleting file %s", entry.Name())
			if err := os.Remove(path); err != nil {
				return err
			}
		}
	}

	return nil
}

// executeTemplate executes a previously parsed template with the data for a specific branch.
func (g *generator) executeTemplate(branch, templateName string) (*bytes.Buffer, error) {
	data := map[string]interface{}{
		"branch":   branch,
		"config":   g.config.Branches[branch],
		"versions": g.config.Versions,
	}

	var out bytes.Buffer

	// Write yaml comment as header to indicate this file got generated.
	out.WriteString(generatedFileHeader)

	if err := g.templates.ExecuteTemplate(&out, templateName, data); err != nil {
		return nil, errors.Wrapf(err, "executing template %q for branch %q", templateName, branch)
	}

	return &out, nil
}

// executeNameTemplate executes a previously parsed name template with the branch as data.
func (g *generator) executeNameTemplate(branch, templateName string) (string, error) {
	data := map[string]interface{}{
		"branch": branch,
	}

	var out bytes.Buffer

	if err := g.nameTemplates[templateName].Execute(&out, data); err != nil {
		return "", errors.Wrapf(err, "executing name template %q for branch %q", templateName, branch)
	}

	return out.String(), nil
}

// templateFunctions returns the functions available inside of templates.
func (g *generator) templateFunctions() template.FuncMap {
	funcs := template.FuncMap{}
	funcs["TrimPrefix"] = strings.TrimPrefix
	funcs["TrimSuffix"] = strings.TrimSuffix
	funcs["ReplaceAll"] = strings.ReplaceAll
	// function cloned from sprig
	funcs["last"] = last
	funcs["list"] = list
	funcs["has"] = has
	funcs["trim"] = strings.TrimSpace
	return funcs
}

func last(list any) any {
	tp := reflect.TypeOf(list).Kind()
	switch tp {
	case reflect.Slice, reflect.Array:
		l2 := reflect.ValueOf(list)

		l := l2.Len()
		if l == 0 {
			return nil
		}

		return l2.Index(l - 1).Interface()
	default:
		panic(fmt.Sprintf("cannot find last on type %s", tp))
	}
}

func list(v ...interface{}) []interface{} {
	return v
}

func has(needle interface{}, haystack interface{}) bool {
	l, err := mustHas(needle, haystack)
	if err != nil {
		panic(err)
	}

	return l
}

func mustHas(needle interface{}, haystack interface{}) (bool, error) {
	if haystack == nil {
		return false, nil
	}
	tp := reflect.TypeOf(haystack).Kind()
	switch tp {
	case reflect.Slice, reflect.Array:
		l2 := reflect.ValueOf(haystack)
		var item interface{}
		l := l2.Len()
		for i := range l {
			item = l2.Index(i).Interface()
			if reflect.DeepEqual(needle, item) {
				return true, nil
			}
		}

		return false, nil
	default:
		return false, fmt.Errorf("cannot find has on type %s", tp)
	}
}
