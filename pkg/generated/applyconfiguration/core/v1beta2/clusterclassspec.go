/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1beta2

// ClusterClassSpecApplyConfiguration represents a declarative configuration of the ClusterClassSpec type for use
// with apply.
//
// ClusterClassSpec describes the desired state of the ClusterClass.
type ClusterClassSpecApplyConfiguration struct {
	// availabilityGates specifies additional conditions to include when evaluating Cluster Available condition.
	//
	// NOTE: If a Cluster is using this ClusterClass, and this Cluster defines a custom list of availabilityGates,
	// such list overrides availabilityGates defined in this field.
	AvailabilityGates []ClusterAvailabilityGateApplyConfiguration `json:"availabilityGates,omitempty"`
	// infrastructure is a reference to a local struct that holds the details
	// for provisioning the infrastructure cluster for the Cluster.
	Infrastructure *InfrastructureClassApplyConfiguration `json:"infrastructure,omitempty"`
	// controlPlane is a reference to a local struct that holds the details
	// for provisioning the Control Plane for the Cluster.
	ControlPlane *ControlPlaneClassApplyConfiguration `json:"controlPlane,omitempty"`
	// workers describes the worker nodes for the cluster.
	// It is a collection of node types which can be used to create
	// the worker nodes of the cluster.
	Workers *WorkersClassApplyConfiguration `json:"workers,omitempty"`
	// variables defines the variables which can be configured
	// in the Cluster topology and are then used in patches.
	Variables []ClusterClassVariableApplyConfiguration `json:"variables,omitempty"`
	// patches defines the patches which are applied to customize
	// referenced templates of a ClusterClass.
	// Note: Patches will be applied in the order of the array.
	Patches []ClusterClassPatchApplyConfiguration `json:"patches,omitempty"`
	// upgrade defines the upgrade configuration for clusters using this ClusterClass.
	Upgrade *ClusterClassUpgradeApplyConfiguration `json:"upgrade,omitempty"`
	// kubernetesVersions is the list of Kubernetes versions that can be
	// used for clusters using this ClusterClass.
	// The list of version must be ordered from the older to the newer version, and there should be
	// at least one version for every minor in between the first and the last version.
	KubernetesVersions []string `json:"kubernetesVersions,omitempty"`
}

// ClusterClassSpecApplyConfiguration constructs a declarative configuration of the ClusterClassSpec type for use with
// apply.
func ClusterClassSpec() *ClusterClassSpecApplyConfiguration {
	return &ClusterClassSpecApplyConfiguration{}
}

// WithAvailabilityGates adds the given value to the AvailabilityGates field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the AvailabilityGates field.
func (b *ClusterClassSpecApplyConfiguration) WithAvailabilityGates(values ...*ClusterAvailabilityGateApplyConfiguration) *ClusterClassSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithAvailabilityGates")
		}
		b.AvailabilityGates = append(b.AvailabilityGates, *values[i])
	}
	return b
}

// WithInfrastructure sets the Infrastructure field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Infrastructure field is set to the value of the last call.
func (b *ClusterClassSpecApplyConfiguration) WithInfrastructure(value *InfrastructureClassApplyConfiguration) *ClusterClassSpecApplyConfiguration {
	b.Infrastructure = value
	return b
}

// WithControlPlane sets the ControlPlane field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ControlPlane field is set to the value of the last call.
func (b *ClusterClassSpecApplyConfiguration) WithControlPlane(value *ControlPlaneClassApplyConfiguration) *ClusterClassSpecApplyConfiguration {
	b.ControlPlane = value
	return b
}

// WithWorkers sets the Workers field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Workers field is set to the value of the last call.
func (b *ClusterClassSpecApplyConfiguration) WithWorkers(value *WorkersClassApplyConfiguration) *ClusterClassSpecApplyConfiguration {
	b.Workers = value
	return b
}

// WithVariables adds the given value to the Variables field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Variables field.
func (b *ClusterClassSpecApplyConfiguration) WithVariables(values ...*ClusterClassVariableApplyConfiguration) *ClusterClassSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithVariables")
		}
		b.Variables = append(b.Variables, *values[i])
	}
	return b
}

// WithPatches adds the given value to the Patches field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Patches field.
func (b *ClusterClassSpecApplyConfiguration) WithPatches(values ...*ClusterClassPatchApplyConfiguration) *ClusterClassSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithPatches")
		}
		b.Patches = append(b.Patches, *values[i])
	}
	return b
}

// WithUpgrade sets the Upgrade field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Upgrade field is set to the value of the last call.
func (b *ClusterClassSpecApplyConfiguration) WithUpgrade(value *ClusterClassUpgradeApplyConfiguration) *ClusterClassSpecApplyConfiguration {
	b.Upgrade = value
	return b
}

// WithKubernetesVersions adds the given value to the KubernetesVersions field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the KubernetesVersions field.
func (b *ClusterClassSpecApplyConfiguration) WithKubernetesVersions(values ...string) *ClusterClassSpecApplyConfiguration {
	for i := range values {
		b.KubernetesVersions = append(b.KubernetesVersions, values[i])
	}
	return b
}
