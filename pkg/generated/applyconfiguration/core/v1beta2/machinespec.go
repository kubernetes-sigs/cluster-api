/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1beta2

// MachineSpecApplyConfiguration represents a declarative configuration of the MachineSpec type for use
// with apply.
//
// MachineSpec defines the desired state of Machine.
type MachineSpecApplyConfiguration struct {
	// clusterName is the name of the Cluster this object belongs to.
	ClusterName *string `json:"clusterName,omitempty"`
	// bootstrap is a reference to a local struct which encapsulates
	// fields to configure the Machineâ€™s bootstrapping mechanism.
	Bootstrap *BootstrapApplyConfiguration `json:"bootstrap,omitempty"`
	// infrastructureRef is a required reference to a custom resource
	// offered by an infrastructure provider.
	InfrastructureRef *ContractVersionedObjectReferenceApplyConfiguration `json:"infrastructureRef,omitempty"`
	// version defines the desired Kubernetes version.
	// This field is meant to be optionally used by bootstrap providers.
	Version *string `json:"version,omitempty"`
	// providerID is the identification ID of the machine provided by the provider.
	// This field must match the provider ID as seen on the node object corresponding to this machine.
	// This field is required by higher level consumers of cluster-api. Example use case is cluster autoscaler
	// with cluster-api as provider. Clean-up logic in the autoscaler compares machines to nodes to find out
	// machines at provider which could not get registered as Kubernetes nodes. With cluster-api as a
	// generic out-of-tree provider for autoscaler, this field is required by autoscaler to be
	// able to have a provider view of the list of machines. Another list of nodes is queried from the k8s apiserver
	// and then a comparison is done to find out unregistered machines and are marked for delete.
	// This field will be set by the actuators and consumed by higher level entities like autoscaler that will
	// be interfacing with cluster-api as generic provider.
	ProviderID *string `json:"providerID,omitempty"`
	// failureDomain is the failure domain the machine will be created in.
	// Must match the name of a FailureDomain from the Cluster status.
	FailureDomain *string `json:"failureDomain,omitempty"`
	// minReadySeconds is the minimum number of seconds for which a Machine should be ready before considering it available.
	// Defaults to 0 (Machine will be considered available as soon as the Machine is ready)
	MinReadySeconds *int32 `json:"minReadySeconds,omitempty"`
	// readinessGates specifies additional conditions to include when evaluating Machine Ready condition.
	//
	// This field can be used e.g. by Cluster API control plane providers to extend the semantic of the
	// Ready condition for the Machine they control, like the kubeadm control provider adding ReadinessGates
	// for the APIServerPodHealthy, SchedulerPodHealthy conditions, etc.
	//
	// Another example are external controllers, e.g. responsible to install special software/hardware on the Machines;
	// they can include the status of those components with a new condition and add this condition to ReadinessGates.
	//
	// NOTE: In case readinessGates conditions start with the APIServer, ControllerManager, Scheduler prefix, and all those
	// readiness gates condition are reporting the same message, when computing the Machine's Ready condition those
	// readinessGates will be replaced by a single entry reporting "Control plane components: " + message.
	// This helps to improve readability of conditions bubbling up to the Machine's owner resource / to the Cluster).
	ReadinessGates []MachineReadinessGateApplyConfiguration `json:"readinessGates,omitempty"`
	// deletion contains configuration options for Machine deletion.
	Deletion *MachineDeletionSpecApplyConfiguration `json:"deletion,omitempty"`
	// taints are the node taints that Cluster API will manage.
	// This list is not necessarily complete: other Kubernetes components may add or remove other taints from nodes,
	// e.g. the node controller might add the node.kubernetes.io/not-ready taint.
	// Only those taints defined in this list will be added or removed by core Cluster API controllers.
	//
	// There can be at most 64 taints.
	// A pod would have to tolerate all existing taints to run on the corresponding node.
	//
	// NOTE: This list is implemented as a "map" type, meaning that individual elements can be managed by different owners.
	Taints []MachineTaintApplyConfiguration `json:"taints,omitempty"`
}

// MachineSpecApplyConfiguration constructs a declarative configuration of the MachineSpec type for use with
// apply.
func MachineSpec() *MachineSpecApplyConfiguration {
	return &MachineSpecApplyConfiguration{}
}

// WithClusterName sets the ClusterName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClusterName field is set to the value of the last call.
func (b *MachineSpecApplyConfiguration) WithClusterName(value string) *MachineSpecApplyConfiguration {
	b.ClusterName = &value
	return b
}

// WithBootstrap sets the Bootstrap field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Bootstrap field is set to the value of the last call.
func (b *MachineSpecApplyConfiguration) WithBootstrap(value *BootstrapApplyConfiguration) *MachineSpecApplyConfiguration {
	b.Bootstrap = value
	return b
}

// WithInfrastructureRef sets the InfrastructureRef field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the InfrastructureRef field is set to the value of the last call.
func (b *MachineSpecApplyConfiguration) WithInfrastructureRef(value *ContractVersionedObjectReferenceApplyConfiguration) *MachineSpecApplyConfiguration {
	b.InfrastructureRef = value
	return b
}

// WithVersion sets the Version field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Version field is set to the value of the last call.
func (b *MachineSpecApplyConfiguration) WithVersion(value string) *MachineSpecApplyConfiguration {
	b.Version = &value
	return b
}

// WithProviderID sets the ProviderID field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ProviderID field is set to the value of the last call.
func (b *MachineSpecApplyConfiguration) WithProviderID(value string) *MachineSpecApplyConfiguration {
	b.ProviderID = &value
	return b
}

// WithFailureDomain sets the FailureDomain field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the FailureDomain field is set to the value of the last call.
func (b *MachineSpecApplyConfiguration) WithFailureDomain(value string) *MachineSpecApplyConfiguration {
	b.FailureDomain = &value
	return b
}

// WithMinReadySeconds sets the MinReadySeconds field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the MinReadySeconds field is set to the value of the last call.
func (b *MachineSpecApplyConfiguration) WithMinReadySeconds(value int32) *MachineSpecApplyConfiguration {
	b.MinReadySeconds = &value
	return b
}

// WithReadinessGates adds the given value to the ReadinessGates field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ReadinessGates field.
func (b *MachineSpecApplyConfiguration) WithReadinessGates(values ...*MachineReadinessGateApplyConfiguration) *MachineSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithReadinessGates")
		}
		b.ReadinessGates = append(b.ReadinessGates, *values[i])
	}
	return b
}

// WithDeletion sets the Deletion field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Deletion field is set to the value of the last call.
func (b *MachineSpecApplyConfiguration) WithDeletion(value *MachineDeletionSpecApplyConfiguration) *MachineSpecApplyConfiguration {
	b.Deletion = value
	return b
}

// WithTaints adds the given value to the Taints field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Taints field.
func (b *MachineSpecApplyConfiguration) WithTaints(values ...*MachineTaintApplyConfiguration) *MachineSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithTaints")
		}
		b.Taints = append(b.Taints, *values[i])
	}
	return b
}
