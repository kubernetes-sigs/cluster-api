/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1beta2

// MachineDeploymentClassHealthCheckChecksApplyConfiguration represents a declarative configuration of the MachineDeploymentClassHealthCheckChecks type for use
// with apply.
//
// MachineDeploymentClassHealthCheckChecks are the checks that are used to evaluate if a MachineDeployment Machine is healthy.
type MachineDeploymentClassHealthCheckChecksApplyConfiguration struct {
	// nodeStartupTimeoutSeconds allows to set the maximum time for MachineHealthCheck
	// to consider a Machine unhealthy if a corresponding Node isn't associated
	// through a `Spec.ProviderID` field.
	//
	// The duration set in this field is compared to the greatest of:
	// - Cluster's infrastructure ready condition timestamp (if and when available)
	// - Control Plane's initialized condition timestamp (if and when available)
	// - Machine's infrastructure ready condition timestamp (if and when available)
	// - Machine's metadata creation timestamp
	//
	// Defaults to 10 minutes.
	// If you wish to disable this feature, set the value explicitly to 0.
	NodeStartupTimeoutSeconds *int32 `json:"nodeStartupTimeoutSeconds,omitempty"`
	// unhealthyNodeConditions contains a list of conditions that determine
	// whether a node is considered unhealthy. The conditions are combined in a
	// logical OR, i.e. if any of the conditions is met, the node is unhealthy.
	UnhealthyNodeConditions []UnhealthyNodeConditionApplyConfiguration `json:"unhealthyNodeConditions,omitempty"`
	// unhealthyMachineConditions contains a list of the machine conditions that determine
	// whether a machine is considered unhealthy.  The conditions are combined in a
	// logical OR, i.e. if any of the conditions is met, the machine is unhealthy.
	UnhealthyMachineConditions []UnhealthyMachineConditionApplyConfiguration `json:"unhealthyMachineConditions,omitempty"`
}

// MachineDeploymentClassHealthCheckChecksApplyConfiguration constructs a declarative configuration of the MachineDeploymentClassHealthCheckChecks type for use with
// apply.
func MachineDeploymentClassHealthCheckChecks() *MachineDeploymentClassHealthCheckChecksApplyConfiguration {
	return &MachineDeploymentClassHealthCheckChecksApplyConfiguration{}
}

// WithNodeStartupTimeoutSeconds sets the NodeStartupTimeoutSeconds field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NodeStartupTimeoutSeconds field is set to the value of the last call.
func (b *MachineDeploymentClassHealthCheckChecksApplyConfiguration) WithNodeStartupTimeoutSeconds(value int32) *MachineDeploymentClassHealthCheckChecksApplyConfiguration {
	b.NodeStartupTimeoutSeconds = &value
	return b
}

// WithUnhealthyNodeConditions adds the given value to the UnhealthyNodeConditions field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the UnhealthyNodeConditions field.
func (b *MachineDeploymentClassHealthCheckChecksApplyConfiguration) WithUnhealthyNodeConditions(values ...*UnhealthyNodeConditionApplyConfiguration) *MachineDeploymentClassHealthCheckChecksApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithUnhealthyNodeConditions")
		}
		b.UnhealthyNodeConditions = append(b.UnhealthyNodeConditions, *values[i])
	}
	return b
}

// WithUnhealthyMachineConditions adds the given value to the UnhealthyMachineConditions field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the UnhealthyMachineConditions field.
func (b *MachineDeploymentClassHealthCheckChecksApplyConfiguration) WithUnhealthyMachineConditions(values ...*UnhealthyMachineConditionApplyConfiguration) *MachineDeploymentClassHealthCheckChecksApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithUnhealthyMachineConditions")
		}
		b.UnhealthyMachineConditions = append(b.UnhealthyMachineConditions, *values[i])
	}
	return b
}
