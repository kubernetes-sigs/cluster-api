# Defining your API

The API generated by Kubebuilder is just a shell. Your actual API will likely have more fields defined on it.

Kubernetes has a lot of conventions and requirements around API design.
The [Kubebuilder docs][apidesign] have some helpful hints on how to design your types.

[apidesign]: https://book.kubebuilder.io/cronjob-tutorial/api-design.html#designing-an-api

Let's take a look at what was generated for us:

```go
// MailgunClusterSpec defines the desired state of MailgunCluster
type MailgunClusterSpec struct {
	// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
	// Important: Run "make" to regenerate code after modifying this file
}

// MailgunClusterStatus defines the observed state of MailgunCluster
type MailgunClusterStatus struct {
	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
	// Important: Run "make" to regenerate code after modifying this file
}
```

Our API is based on Mailgun, so we're going to have some email based fields:

```go
type Priority string

const (
	// PriorityUrgent means do this right away
	PriorityUrgent = Priority("Urgent")

	// PriorityUrgent means do this immediately
	PriorityExtremelyUrgent = Priority("ExtremelyUrgent")

	// PriorityBusinessCritical means you absolutely need to do this now
	PriorityBusinessCritical = Priority("BusinessCritical")
)

// MailgunClusterSpec defines the desired state of MailgunCluster
type MailgunClusterSpec struct {
	// Priority is how quickly you need this cluster
	Priority Priority `json:"priority"`
	// Request is where you ask extra nicely
	Request string `json:"request"`
	// Requester is the email of the person sending the request
	Requester string `json:"requester"`
}

// MailgunClusterStatus defines the observed state of MailgunCluster
type MailgunClusterStatus struct {
	// MessageID is set to the message ID from Mailgun when our message has been sent
	MessageID *string `json:"response"`
}
```

As the deleted comments request, run `make manager manifests` to regenerate some of the generated data files afterwards.

```bash
git add .
git commit -m "Added cluster types"
```

# Registering APIs in the scheme

To enable clients to encode and decode your API, your types must be able to be registered within a [scheme].

[scheme]: https://pkg.go.dev/k8s.io/apimachinery/pkg/runtime#Scheme

By default, Kubebuilder will provide you with a scheme builder like:

```go
import "sigs.k8s.io/controller-runtime/pkg/scheme"

var (
	// SchemeBuilder is used to add go types to the GroupVersionKind scheme
	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = SchemeBuilder.AddToScheme
)
```

and scheme registration that looks like:

```go
func init() {
	SchemeBuilder.Register(&Captain{}, &CaptainList{})
}
```

This pattern introduces a dependency on controller-runtime to your API types, which is discouraged for
API packages as it makes it more difficult for consumers of your API to import your API types.
In general, you should minimise the imports within the API folder of your package to allow your API types
to be imported cleanly into other projects.

To mitigate this, use the following schemebuilder pattern:

```go
import "k8s.io/apimachinery/pkg/runtime"

var (
	// schemeBuilder is used to add go types to the GroupVersionKind scheme.
	schemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)

	// AddToScheme adds the types in this group-version to the given scheme.
	AddToScheme = schemeBuilder.AddToScheme

	objectTypes = []runtime.Object{}
)

func addKnownTypes(scheme *runtime.Scheme) error {
	scheme.AddKnownTypes(GroupVersion, objectTypes...)
	metav1.AddToGroupVersion(scheme, GroupVersion)
	return nil
}
```

and register types as below:

```go
func init() {
	objectTypes = append(objectTypes, &Captain{}, &CaptainList{})
}
```

This pattern reduces the number of dependencies being introduced into the API package within your project.
